Traceback (most recent call last):
  File "/Users/janreimann/miniforge3/envs/jup/lib/python3.9/site-packages/jupyter_cache/executors/utils.py", line 51, in single_nb_execution
    executenb(
  File "/Users/janreimann/miniforge3/envs/jup/lib/python3.9/site-packages/nbclient/client.py", line 1112, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "/Users/janreimann/miniforge3/envs/jup/lib/python3.9/site-packages/nbclient/util.py", line 74, in wrapped
    return just_run(coro(*args, **kwargs))
  File "/Users/janreimann/miniforge3/envs/jup/lib/python3.9/site-packages/nbclient/util.py", line 53, in just_run
    return loop.run_until_complete(coro)
  File "/Users/janreimann/miniforge3/envs/jup/lib/python3.9/asyncio/base_events.py", line 642, in run_until_complete
    return future.result()
  File "/Users/janreimann/miniforge3/envs/jup/lib/python3.9/site-packages/nbclient/client.py", line 553, in async_execute
    await self.async_execute_cell(
  File "/Users/janreimann/miniforge3/envs/jup/lib/python3.9/site-packages/nbclient/client.py", line 857, in async_execute_cell
    self._check_raise_for_error(cell, exec_reply)
  File "/Users/janreimann/miniforge3/envs/jup/lib/python3.9/site-packages/nbclient/client.py", line 760, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
from __future__ import print_function
from ipywidgets import interact, interactive, fixed, interact_manual
import ipywidgets as widgets
from traitlets import traitlets
from IPython.display import display, Math, Latex
import matplotlib.pyplot as plt
import numpy as np
import sympy as sp
from functools import partial




#
# Auxiliary functions needed to parse function string inputs
#


# operator dictionary
unary_operators=['neg','sqrt','abs','exp','log','sin','cos','tan','sec','csc','cot','arcsin','arccos','arctan','arcsec','arccsc','arccot']
binary_operators=['+','-','*','/','^']

#Reserve some symbols in Sympy
x, y, z, h = sp.symbols('x y z h')


def is_number(s):
    # checks whether the string s is a number (integer or float)
    try:
        float(s)
        return True
    except ValueError:
        return False
    
def is_letter(s):
    # checks whether the string s is a single letter. Returns false if s contains more than one character
    if len(s)==1 and s.isalpha():
        return True
    return False

def needs_times(string,i):
    # accepts a string and in index i. Returns true if string needs a '*' character inserted between positions i and i+1 in order to be properly interpreted as a function
    if i==len(string)-1:
        return False
    
    if is_letter(string[i]) and is_number(string[i+1]):
        return True
    if is_letter(string[i+1]) and is_number(string[i]):
        return True
    if is_number(string[i]) and string[i+1]=='(':
        return True
    if is_letter(string[i]) and string[i+1]=='(' and get_adjacent_characters(string,i)[0] not in unary_operators:
        return True
    if string[i]==')' and is_letter(string[i+1]):
        return True
    if string[i]==')' and is_number(string[i+1]):
        return True
    if string[i]==')' and string[i+1]=='(':
        return True
    
    return False

def get_adjacent_characters(string,i,test=lambda x:is_letter(x)):
    # returns a triple of the form [s,a,b] where s is the largest substring of string containing the index i where all the characters match a specific form. The default is that all the characters in s are letters. a and b are the indices in string of the first and last chcaracters in s respectively.
    s=string[i]

    if not test(s):
        return []
    
    j=i+1
    while j<len(string) and test(string[j]):
        s=s+string[j]
        j+=1
    
    k=i-1
    while k>-1 and test(string[k]):
        s=string[k]+s
        k-=1
    
    return [s,k+1,j-1]

def fix_minuses(string):
    # adjusts a string to account for the inconvenient fact that the '-' symbol can be interpreted as either a minus sign or a negative sign.
    i=0
    while i<len(string):
        if string[i]=='-':
            [m,a,b]=get_adjacent_characters(string,i,test=lambda x:x=='-')
            if a==0:
                if b%2==1:
                    string=string[b+1:]
                else:
                    string='-'+string[b+1:]
                i=0
            elif b<len(string)-1:
                s1=string[:a]
                s2=string[b+1:]
                if string[a-1] in ['+','*','/','^']:
                    if (b-a)%2==1:
                        string=s1+s2
                    else:
                        string=s1+'-'+s2
                else:
                    if (b-a)%2==1:
                        string=s1+'+'+s2
                    else:
                        string=s1+'-'+s2
                i=a+1
            else:
                if (b-a)%2==1:
                    string=string[:a]
                else:
                    string=string[:a]+'-'
                i=len(string)-1
        i+=1
    return string
                
                
def add_times(string):
    i=0
    while i<len(string):
        if string[i]==' ':
            ws=get_adjacent_characters(string,i,test=lambda x:x==' ')
            if ws[1]==0:
                string=string[ws[2]+1:]
            elif ws[2]==len(string)-1:
                string=string[:ws[1]]
            elif is_letter(string[ws[1]-1]) and is_letter(string[ws[2]+1]):
                string=string[:ws[1]]+'*'+string[ws[2]+1:]
            else:
                string=string[:ws[1]]+'*'+string[ws[2]+1:]
            i-=1
        if needs_times(string,i):
            string=string[:i+1]+'*'+string[i+1:]    
        i+=1
        
    return string


def check_adjacency(s):
    if s[0]=='(' and s[1]==')':
        return ['emptry parentheses: ()']
    if s[0]=='(' and s[1] in ['+','*','/','^']:
        return ['empty operand: '+s]
    if s[0] in binary_operators and s[1]==')':
        return ['empty operand: '+s]
    if s[0] in binary_operators and s[1] in ['+','*','/','^']:
        return ['double operator: '+s]
    
    return []


def get_variables(list_form):
    var=list(set(get_variables_dup(list_form)))
    var.sort()
    return var

def get_variables_dup(list_form):
    if  type(list_form) is not list:
        if is_number(list_form):
            return []
        else:
            return [list_form]
        
    if len(list_form)==2:
        return get_variables(list_form[1]) 
    else:
        return get_variables(list_form[1])+get_variables(list_form[2])


#
# end auxiliary parsing functions
#



# Check format of input string whether it corresponds to "correct" expression
def check_format(string):
    if string=='':
        return ['empty']
    issues=[]
    nest_level=0
    neg=False;
    for i in range(len(string)):
        if string[i]=='(':
            nest_level+=1
        if string[i]==')':
            nest_level-=1
        if nest_level<0:
            neg=True
        if i<len(string)-1:
            issues+=check_adjacency(string[i:i+2])
        if (string[i] not in binary_operators) and (not is_letter(string[i])) and (not is_number(string[i])) and (string[i] not in ['.','(',')']): 
            issues+=['invalid character: '+string[i]]
    if nest_level>0:
        issues+=['more open parentheses than close parentheses']
    if nest_level<0:
        issues+=['more close parentheses than open parentheses']
    if neg:
        issues+=['parentheses unbalanced']
            
    if string[0] in ['+','*','/','^']:
        issues+=['cannot begin with an operator']
    
    if string[-1] in binary_operators:
        issues+=['cannot end with an operator']
    
    i=0
    while i<len(string):
        if is_letter(string[i]):
            word=get_adjacent_characters(string,i)
            if word[0] in unary_operators and (word[2]==len(string)-1 or not string[word[2]+1]=='('):
                issues+=['function '+word[0]+' must be followed by parentheses']
            i=word[2]
        i+=1
    
    return issues



def to_list_form(string):
    if string[0]=='-':
        neg=True
    else:
        neg=False

    nest_level=0
    plus=[]
    minus=[]
    times=[]
    divide=[]
    power=[]
    for i in range(len(string)):
        if string[i]=='(':
            nest_level+=1
        if string[i]==')':
            nest_level-=1
        if string[i]=='+' and nest_level==0:
            plus+=[i]
        if string[i]=='-' and nest_level==0 and (i==0 or (i>0 and string[i-1] not in ['*','/','^'])):
            minus+=[i]
        if string[i]=='*' and nest_level==0:
            times+=[i]
        if string[i]=='/' and nest_level==0:
            divide+=[i]
        if string[i]=='^' and nest_level==0:
            power+=[i]
    
    if len(plus)>0:
        pos=plus[0]
    elif len(minus)>0 and not neg:
        pos=minus[0]
    elif len(minus)>1 and neg:
        pos=minus[1]
    elif len(times)>0:
        pos=times[0]
    elif len(divide)>0:
        pos=divide[0]
    elif len(power)>0:
        pos=power[0]
    else:
        pos=-1
    if pos>-1:
        return [string[pos],
                to_list_form(string[:pos]),
                to_list_form(string[pos+1:])]
    
    if string[0]=='(' and string[-1]==')':
        return to_list_form(string[1:-1])        
    
    if neg:
        return ['neg',to_list_form(string[1:])]
    for func in unary_operators:
        if string.startswith(func):
            return [func,to_list_form(string[len(func):])]
        
    return string





class BaseFunction:

    def __init__(self,*args):
        
        if len(args) > 0:
            self.set_function(args[0])
        else:
            self.set_function()
            

    def set_function(self,*args):
        
        if len(args) == 0:
            self.str_form = ''
            self.list_form = []
            self.tex_form = ''                
            self.sym_form = sp.sympify('-1')
            self.compilable = False
            self.func_is_defined = False

        # parse argument according to type (string or sympy expression)
        elif type(args[0]) == str:
            
            # perform some pre-processing  
            self.str_form=fix_minuses(add_times(args[0]))

            # check format of input string
            self.issues=check_format(self.str_form)

            # if format ok, try to convert to various forms
            if len(self.issues)==0:

                self.compileable=True

                try:
                    # get list_form
                    self.list_form=to_list_form(self.str_form)

                    # collect variables and get symbolic form

                    # get the variables from the list form and put them in a string
                    self.func_symbols = get_variables(self.list_form)

                    # now create sympy symbols for each variable symbol found
                    if len(self.func_symbols) > 0:
                        var_string=self.func_symbols[0]
                        i=1
                        while i < len(self.func_symbols):
                            var_string+=' '+self.func_symbols[i]
                            i+=1

                        self.func_vars = sp.symbols(var_string)

                    # create sympy expression from input string, converting usual exp sign to Python exp
                    self.sym_form = sp.sympify(self.str_form.replace('^','**'))

                    # use sympy converter to initialize tex form
                    self.tex_form = sp.latex(self.sym_form)

                    # Set "defined" flag
                    self.func_is_defined = True

                except:
                    self.compileable=False
                    self.list_form=[]
                    self.sym_form=sp.sympify('-1')
                    self.tex_form=''
                    self.issues=['This function could not be compiled for an unknown reason']
                    self.func_is_defined = False

            else:
                self.compileable=False
                self.list_form=[]
                self.sym_form=sp.sympify('-1')
                self.tex_form = ''
                self.func_is_defined = False


        # if agrument is sympy expression, we can initialize right away        
        elif isinstance(args[0], tuple(sp.core.all_classes)):
            self.sym_form = args[0]
            self.compileable=False
            self.str_form = str(self.sym_form)
            self.list_form=[]
            self.tex_form = sp.latex(self.sym_form)
            self.func_is_defined = True

            

        else:
            self.compileable=False
            self.list_form=[]
            self.sym_form=sp.sympify('-1')
            self.tex_form = ''
            self.func_is_defined = False



            
            

    # check whether function is equal to a given expression
    def check_function(self,expr):
        
        if self.func_is_defined == True:
            
            print(expr)
            test_function = BaseFunction(expr['new'])
            print(self.tex_form) 
            print(test_function.tex_form)
            if sp.simplify(self.sym_form-test_function.sym_form) == 0:
                print("Correct!")
                return True
            else:
                print("Not correct.")
                return False
                    
    

        
# Derive a function class with widget methods: 
class WidgetFunction(BaseFunction):

    def __init__(self, *args):
        if len(args) == 0:
            self.get_input_from_widget()
        else:
            self.set_function(args[0])
            
            
    def set_function_on_click(self,input_text,button):
        
        self.set_function(input_text.value)
        print("You entered: ")
        display(Math(self.tex_form))
        
        
    def get_input_from_button_widget(self):
        
        w_g = widgets.Text(
            value='',
            placeholder='Type something',
            description='g(x) = ',
            continuous_update=False,
            disabled=False
        )

        display(w_g)
        button = widgets.Button(description="Submit")
        display(button)
        button.on_click(partial(self.set_function_on_click,w_g))
    
    
    def subs_into_function(self,expr):
        
        return self.sym_form.subs(vars[0], expr)
    
    
        
    def check_function_against_input(self, name):

        input_field = widgets.Text(
            value='',
            placeholder='Type answer and press enter',
            description= name + ' = ',
            continuous_update=False,
            disabled=False
        )

        input_field.observe(self.evaluate_text_input, names='value')            
        display(input_field)
            

            
    # check whether function is equal to a given expression
    def evaluate_text_input(self,expr):
        
        input_function = BaseFunction(expr['new'])
        print("You entered: ") 
        display(Math(input_function.tex_form))

        if sp.simplify(self.sym_form - input_function.sym_form) == 0:
            print("Correct!")
            return True
        else:
            print("Not correct. Please try again.")
            return False



# def evaluate_text_input_against_expr(self,expr):

#     input_function = BaseFunction(expr['new'])
#     print("You entered: ") 
#     display(Math(input_function.tex_form))

#     if sp.simplify(self.sym_form - input_function.sym_form) == 0:
#         print("Correct!")
#         return True
#     else:
#         print("Not correct. Please try again.")
#         return False


        
# def check_expr_against_input(expr):
#     w_g = widgets.Text(
#         value='',
#         placeholder='Type and press Enter',
#         description='Your answer: ',
#         continuous_update=False,
#         disabled=False
#     )

#     display(w_g)
#     button = widgets.Button(description="Submit")
#     display(button)
#     button.on_click(partial(self.set_function_on_click,w_g))

   
------------------

[0;31m---------------------------------------------------------------------------[0m
[0;31mModuleNotFoundError[0m                       Traceback (most recent call last)
[0;32m<ipython-input-1-e432213ed182>[0m in [0;36m<module>[0;34m[0m
[1;32m      4[0m [0;32mfrom[0m [0mtraitlets[0m [0;32mimport[0m [0mtraitlets[0m[0;34m[0m[0;34m[0m[0m
[1;32m      5[0m [0;32mfrom[0m [0mIPython[0m[0;34m.[0m[0mdisplay[0m [0;32mimport[0m [0mdisplay[0m[0;34m,[0m [0mMath[0m[0;34m,[0m [0mLatex[0m[0;34m[0m[0;34m[0m[0m
[0;32m----> 6[0;31m [0;32mimport[0m [0mmatplotlib[0m[0;34m.[0m[0mpyplot[0m [0;32mas[0m [0mplt[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m      7[0m [0;32mimport[0m [0mnumpy[0m [0;32mas[0m [0mnp[0m[0;34m[0m[0;34m[0m[0m
[1;32m      8[0m [0;32mimport[0m [0msympy[0m [0;32mas[0m [0msp[0m[0;34m[0m[0;34m[0m[0m

[0;31mModuleNotFoundError[0m: No module named 'matplotlib'
ModuleNotFoundError: No module named 'matplotlib'

